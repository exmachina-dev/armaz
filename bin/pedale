#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from ertza.remotes.modbus.modbus import ModbusBackend, ModbusDeviceConfig
from ertza.remotes.io.serial_remote import SerialControlLink
from ertza.remotes.io.event_watcher import EventWatcher as SwitchHandler

from ertza.error import SerialError

from threading import Event, Thread

import atexit
import signal
import logging

lg = logging.getLogger(__name__)
lg.setLevel(logging.DEBUG)

class GrossePedale(object):
    def __init__(self):

        self.exit_event = Event()
        self.block_event = Event()
        self.connected_event = Event()
        self.ready_event = Event()
        self.restart_event = Event()

        atexit.register(self.exit)

        self.mb = ModbusBackend(None, lg, restart_event=self.restart_event,
                block_event=self.block_event,
                connected_event=self.connected_event,
                watch_event=self.exit_event)

        self.mb.word_lenght = 16
        self.mb.data_bit = 8
        self.mb.encoder_ration = 10000
        self.mb.nb_reg_by_comms = int(self.mb.word_lenght / self.mb.data_bit)
        self.mb.auto_enable = True
        self.mb.set_direction(0) # Move forward by default

        dev_conf = ModbusDeviceConfig('192.168.100.2', 502, 2,
            {'encoder_ratio' : 10000,})
        self.mb.devices_config.append(dev_conf)
        dev_conf = ModbusDeviceConfig('192.168.100.3', 502, 3,
            {'encoder_ratio' : 10000,})
        self.mb.devices_config.append(dev_conf)

        dev = '/dev/ttyO2'
        self.s = SerialControlLink(dev)
        self.s.daemon_event = self.exit_event

        self.mt = Thread(target=self.modbus_thread)
        self.st = Thread(target=self.swill_thread)
        self.mt.daemon = True
        self.st.daemon = True

    def start(self):
        self.mb.connect()
        self.mb.set_acceleration(40)
        self.mb.set_deceleration(20)
        self.mt.start()
        self.st.start()
        self.io_launch()

        try:
            signal.pause()
        except KeyboardInterrupt:
            lg.info('Keyboard interrupt received, exiting.')

    def exit(self):
        self.exit_event.set()
        self.mb.close()

    def modbus_thread(self):
        while not self.exit_event.is_set():
            self.mb.state_watcher()
            self.exit_event.wait(1/500)
        self.mb.close()

    def swill_thread(self):
        while not self.exit_event.is_set():
            try:
                tk, tu, ms = self.s.safe_get()
                if not self.block_event.is_set():
                    self.mb.set_speed(ms)
            except SerialError:
                self.lg.warn('Swill mised to much data. Stopping.')
                self.mb.set_speed(0)

    def io_launch(self):
        SWITCH_PINS = (("GPIO0_30", 1, 'switch_0'), ("GPIO0_31", 2, 'switch_1'))

        switchs = list()
        self.switchs_actions = {}

        SwitchHandler.callback = self.io_callback
        SwitchHandler.inputdev = '/dev/input/event1'

        switchs.append(SwitchHandler('GPIO0_30', 1, 'switch_0', invert=True))
        self.switchs_actions['switch_0'] = 'reverse'
        switchs.append(SwitchHandler('GPIO0_31', 2, 'switch_1'))
        self.switchs_actions['switch_1'] = 'activate'
        self.switchs = tuple(switchs)

        for sw in self.switchs:
            t = Thread(target=sw.wait_for_event)
            t.daemon = True
            t.start()

    def io_callback(self, ev):
        if self.switchs_actions[ev.name] == 'reverse':
            self.mb.set_direction(ev.state)
        elif self.switchs_actions[ev.name] == 'activate':
            self.mb.set_command(drive_enable=ev.state)

if __name__ == '__main__':
    gp = GrossePedale()
    gp.start()
