#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from ertza.remotes.modbus.modbus import ModbusBackend, ModbusDeviceConfig
from ertza.remotes.io.serial_remote import SerialControlLink
from ertza.remotes.io.event_watcher import EventWatcher as SwitchHandler

from threading import Event, Thread

import atexit

def init():
    mb = ModbusBackend(None, None, None, Event())

    mb.word_lenght = 16
    mb.data_bit = 8
    mb.encoder_ration = 10000
    mb.nb_reg_by_comms = int(mb.word_lenght / mb.data_bit)
    mb.auto_enable = True

    device_config = ModbusDeviceConfig('192.168.100.2', 502, 2,
        {'encoder_ratio' : 10000,})
    mb.devices_config.append(device_config)
    device_config = ModbusDeviceConfig('192.168.100.3', 502, 3,
        {'encoder_ratio' : 10000,})
    mb.devices_config.append(device_config)

    mb.connect()

    dev = '/dev/ttyO2'
    s = SerialControlLink(dev)
    s.daemon_event = Event()

    mt = Thread(target=modbus_thread)
    st = Thread(target=swill_thread)
    io_launch()

@atexit.register
def exit():
    s.daemon_event.set()


def modbus_thread():
    while not s.daemon_event.is_set():
        mb.state_watcher()
        s.daemon_event.wait(1/500)
    mb.close()

def swill_thread():
    while not s.daemon_event.is_set():
        s.get_last_data()
        s.get_ticks()
        s.map_to_speed(s.last_ticks)
        mb.set_speed(s.last_mapped_speed)

def io_launch():
    SWITCH_PINS = (("GPIO0_30", 1, 'switch_0'), ("GPIO0_31", 2, 'switch_1'))

    switchs = list()
    switchs_actions = {}

    SwitchHandler.callback = io_callback
    SwitchHandler.inputdev = '/dev/input/event1'

    switchs.append(SwitchHandler('GPIO0_30', 1, 'switch_0'))
    switchs_actions['switch_0'] = 'reverse'
    switchs.append(SwitchHandler('GPIO0_31', 2, 'switch_1'))
    switchs_actions['switch_0'] = 'activate'
    switchs = tuple(switchs)

    for sw in switchs:
        t = Thread(target=sw.wait_for_event)
        t.daemon = True
        t.start()

def io_callback(ev):
    if switchs_actions[event.name] == 'reverse':
        mb.set_direction(state)
    elif switchs_actions[event.name] == 'activate':
        mb.set_command(drive_enable=state)

if __name__ == '__main__':
    init()
