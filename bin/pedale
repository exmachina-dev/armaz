#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from ertza.remotes.modbus.modbus import ModbusBackend, ModbusDeviceConfig
from ertza.remotes.io.serial_remote import SerialControlLink
from ertza.remotes.io.event_watcher import EventWatcher as SwitchHandler

from ertza.errors import SerialError, ModbusMasterError

from threading import Event, Thread

from serial.serialutil import SerialException

import atexit
import signal
import time
import logging

logging.basicConfig(level=logging.INFO)
lg = logging.getLogger('LaVoiture')
lg.setLevel(logging.INFO)

class GrossePedale(object):
    def __init__(self, cmdargs=None):
        self.without_rf = cmdargs.get('disable_rf', False)
        self.lg = lg

        self.exit_event = Event()
        self.block_event = Event()
        self.rfok_event = Event()
        self.connected_event = Event()
        self.ready_event = Event()
        self.restart_event = Event()

        self.rf_timeout = 0.25
        self.rf_lasttime = 0

        atexit.register(self.exit)

        self.mb = ModbusBackend(None, self.lg, restart_event=self.restart_event,
                block_event=self.block_event,
                connected_event=self.connected_event,
                watch_event=self.exit_event)

        self.mb.word_lenght = 16
        self.mb.data_bit = 8
        self.mb.encoder_ration = 10000
        self.mb.nb_reg_by_comms = int(self.mb.word_lenght / self.mb.data_bit)
        self.mb.auto_enable = True
        self.mb.set_direction(0) # Move forward by default

        self.acceleration = 60
        self.deceleration = 40

        dev_conf = ModbusDeviceConfig('192.168.100.2', 502, 2,
            {'encoder_ratio' : 10000,})
        self.mb.devices_config.append(dev_conf)
        dev_conf = ModbusDeviceConfig('192.168.100.3', 502, 3,
            {'encoder_ratio' : 10000,})
        self.mb.devices_config.append(dev_conf)

        dev = '/dev/ttyO2'
        try:
            SerialControlLink.max_speed = 72.5
            self.s = SerialControlLink(dev)
            self.s.daemon_refresh = (1/50)
            self.s.daemon_event = self.exit_event
        except SerialException:
            self.ready_event.clear()

        if self.without_rf:
            self.thread_targets = (self.modbus_thread, self.modbus_watchdog,
                    self.swill_thread,)
        else:
            self.thread_targets = (self.modbus_thread, self.modbus_watchdog,
                    self.swill_thread, self.radio_thread,)

        self.threads = list()
        for i, tt in enumerate(self.thread_targets):
            self.threads.append(Thread(target=tt))
            self.threads[i].daemon = True

    def start(self):
        self.mb.connect()
        self.mb.set_acceleration(self.acceleration)
        self.mb.set_deceleration(self.deceleration)
        self.ready_event.wait(2)
        n_acc = self.mb.get_acceleration()
        n_dec = self.mb.get_deceleration()
        self.io_launch()
        for t in self.threads:
            t.start()

        if self.without_rf:
            self.rfok_event.set()

        self.ready_event.set()

        try:
            signal.pause()
        except KeyboardInterrupt:
            self.lg.info('Keyboard interrupt received, exiting.')

    def exit(self):
        self.exit_event.set()
        self.mb.close()

    def modbus_thread(self):
        self.lg.info('Modbus thread started.')
        while not self.exit_event.is_set():
            try:
                self.mb.set_acceleration(self.acceleration)
                self.mb.set_deceleration(self.deceleration)
                self.mb.state_watcher()
                self.lg.info('Running at: {}'.format(
                            self.mb.devices_state.speed))
            except ModbusMasterError as e:
                self.lg.error(e)
            self.exit_event.wait(1/50)
        self.mb.close()

    def modbus_watchdog(self):
        self.lg.info('Modbus watchdog started.')
        while not self.exit_event.wait(1/50):
            try:
                if not self.rfok_event.is_set() or self.block_event.is_set():
                    self.lg.info('Modbus watchdog is blocking.')
                    self.mb.set_speed(0)
                    self.exit_event.wait(0.5)
                    self.mb.set_command(drive_enable=0)
                else:
                    for d in self.mb.devices:
                        if self.mb.can_be_enabled(d.config.host) is True:
                            self.mb.set_speed(0, target=d)
                            self.mb.set_command(drive_enable=1, target=d)
            except ModbusMasterError as e:
                self.lg.error(e)

    def swill_thread(self):
        self.lg.info('Swill thread started.')
        while not self.exit_event.is_set():
            try:
                tk, tu, ms = self.s.safe_get()
                if not self.block_event.is_set() and \
                        self.rfok_event.is_set():
                    if tk is not False:
                        self.mb.set_speed(ms)
                    self.lg.info('Actual speed: {}'.format(ms))
                else:
                    self.mb.set_speed(0)
            except SerialError:
                self.lg.warn('Swill mised to much data. Stopping.')
                self.mb.set_speed(0)
            except ModbusMasterError as e:
                self.lg.error(e)

    def io_launch(self):
        SWITCH_PINS = (("GPIO0_30", 1, 'switch_0'), ("GPIO0_31", 2, 'switch_1'))

        switchs = list()
        self.switchs_actions = {}

        SwitchHandler.callback = self.io_callback
        SwitchHandler.inputdev = '/dev/input/event1'

        switchs.append(SwitchHandler('GPIO0_30', 1, 'switch_0', invert=True))
        self.switchs_actions['switch_0'] = 'reverse'
        switchs.append(SwitchHandler('GPIO0_31', 2, 'switch_1'))
        self.switchs_actions['switch_1'] = 'activate'
        self.switchs = tuple(switchs)

        for sw in self.switchs:
            t = Thread(target=sw.wait_for_event)
            t.daemon = True
            t.start()

        self.lg.info('IOs threads started.')

    def radio_thread(self):
        self.lg.info('RF thread started.')
        while not self.exit_event.wait(1/50):
            if (time.time() - self.rf_lasttime) >= self.rf_timeout:
                self.rfok_event.clear()
                self.lg.debug('RF timeout.')

    def io_callback(self, ev):
        if self.switchs_actions[ev.name] == 'reverse':
            self.mb.set_direction(ev.state)
            dr = 'backward' if ev.state else 'forward'
            self.lg.info('Setting direction to %s.' % dr)
        elif self.switchs_actions[ev.name] == 'activate':
            self.rfok_event.set()
            self.rf_lasttime = time.time()


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(prog='pedale')
    parser.add_argument('--disable-rf', action='store_true',
            help='disable rf switch')
    args = parser.parse_args()

    gp = GrossePedale(vars(args))
    gp.start()
